{\rtf1\ansi\ansicpg1252\cocoartf2759
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\fnil\fcharset0 HelveticaNeue;}
{\colortbl;\red255\green255\blue255;}
{\*\expandedcolortbl;;}
\margl1440\margr1440\vieww22500\viewh13440\viewkind0
\deftab560
\pard\pardeftab560\slleading20\partightenfactor0

\f0\fs38 \cf0 This seems to be a maximization problem, such that there are cases where some assignments may result in less users being served whereas other assignments may result in more users being served. \
\
For a user and a satellite, let us come up with an example of a valid assignment, an invalid assignment due to constraint 1, an invalid assignment due to constraint 2.\
\
An obvious case in which constraint 1 passes is when a sat is directly above and a second user is angled at more than 10 degrees from this connection.\
\
A case in which constraint 2 does not pass is a case in which a user and a sat are angled at 46 degrees from vertical.\
\
A case in which constraint 3 does not pass is when both users are within 10 degrees of each other.\
\
To solve this problem, we need to calculate the angle between the user and a sat. Earth\'92s center is at and vertical shall be the vector from the center to the user. Then there is another vector between the user and the sat. We need to calculate the angle in between both of these vectors. In the case when user is (0, 1, 0), we calculate the \
\
We also need to calculate the angle between two vectors, user 1 and the sat, and user 2 and the sat.\
\
A naive solution would iterate through all possible combinations between users and sats to form connections, but we must take a more intelligent approach because this would be runtime O(N*M), where N is the number of users and M is the number of sats.\
\
The approach we will take is to implement the brute force solution, then optimize from here to get the rest of the test cases.\
\
\pard\pardeftab560\slleading20\partightenfactor0

\fs40 \cf0 For the brute force approach, we will iterate through all of the satellites and find out which ones have valid users. Once we have this set of valid users, we will start assigning users to them but before we do we will have to check every user that has been assigned to make sure that it satisfies this constraint. Once we assign a user to a sat then we can no longer use that so we will need a way to keep track of that too. We will do that by checking the resulting dict.\
\
Now we have to take into account the colors. To do this we will create colorA, colorB, colorC, and colorD buckets and for every user in the potential users, we will check all the colors in each of the buckets until we find one that does not have any within 10 degrees of it.\
\
Also, we need to keep in mind that each satellite cannot have more than 32 beams. We will create a counter for each of the sattellites and if we reach the max of one sattelite then we will check the next one.\
\
We can consider a greedy approach based on trying users that are close to each other. When this happens, we will group them together and assign a sattellite to them.\
\
We need to cluster the users together but how do we do that?\
\
For every user we will see how many sats can serve them. We will assign a negative weight to all of the users and order them by that.}